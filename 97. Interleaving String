/* Question: check if s3 are combination of s1 and s2
1. initial dp[0][0], s1 and s2 if it is begining of s3
2. go through s3:
    1) check current dp
    2) check if current s3 element is from s1
    3) check if current s3 element is from s2
3. return the last element bool
*/
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int m = s1.size(), n=s2.size();
        if(m+n!=s3.size()) return false;

        vector<vector<int>> dp(m+1, vector<int> (n+1, 0));
        dp[0][0] = true;
        for(int i=1; i<=m; i++) dp[i][0] = dp[i-1][0] && s1[i-1] == s3[i-1];
        for(int j=1; j<=n; j++) dp[0][j] = dp[0][j-1] && s2[j-1] == s3[j-1];

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                dp[i][j] = (dp[i-1][j] && s1[i-1]==s3[i+j-1]) || 
                           (dp[i][j-1] && s2[j-1]==s3[i+j-1]);
            }
        }
        return dp[m][n];
    }
};

// advance: use only dp(n+1) for store s1 and s2 status
// class Solution {
// public:
//     bool isInterleave(string s1, string s2, string s3) {
//         int m = s1.size(), n = s2.size();
//         if(m+n != s3.size()) return false;
//         vector<int> dp(n + 1, false);

//         dp[0] = true;
//         //initial dp by s2
//         for(int j=1; j<=n; j++) dp[j] = dp[j-1] && s2[j-1] == s3[j-1];
        
//         for(int i=1; i<=m; i++){
//             //initial dp by s1, update s1 status first for dp[j-1]
//             dp[0] = dp[0] && s1[i-1] == s3[i-1];
//             for(int j=1; j<=n; j++){
//                 dp[j] = (dp[j] && s1[i-1] == s3[i+j-1]) ||  //update s1 status
//                         (dp[j-1] && s2[j-1] == s3[i+j-1]);  //update s2 status
//             }
//         }
//         return dp[n];
//     }
// };
